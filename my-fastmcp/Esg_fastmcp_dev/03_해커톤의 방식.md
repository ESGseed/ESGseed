**해커톤 D-4라면 하드코딩이 정답입니다.**

지금은 **"완벽한 구조"보다 "확실하게 돌아가는 데모"**가 훨씬 중요합니다. RAG나 동적 로딩을 구현하다가 에러 잡느라 시간을 뺏기면 시연 때 보여줄 게 없어질 위험이 큽니다.

### 왜 지금은 하드코딩인가?

1.  **확실한 시연 시나리오:** 해커톤 발표는 보통 3~5분입니다. 심사위원은 내부 코드가 얼마나 우아한지 모릅니다. 입력 넣었을 때 "와, 이걸 잡아내네?" 하는 결과물만 봅니다. 하드코딩은 시연용 예제 데이터(Golden Data)에 대해 100% 성공을 보장합니다.
2.  **디버깅 속도:** 시연 10분 전에도 수정할 수 있습니다. `RULES` 리스트에 튜플 하나만 추가하면 바로 반영되니까요.
3.  **복잡도 제거:** LLM API 호출 실패, 레이턴시, 환각 문제 등을 고민할 필요가 없습니다.

### 추천 전략 (D-4 생존 가이드)

1.  **시나리오 중심 개발 (Scenario-Driven Development):**
    *   시연 때 입력할 텍스트를 미리 **딱 3개** 정하세요. (예: 잘 된 케이스, 엉망인 케이스, 애매한 케이스)
    *   그 3개 텍스트가 완벽하게 매핑되고 검증되도록 `RULES`와 `_validate_disclosure_internal` 조건을 때려 박으세요.
    *   **팁:** 시연용 텍스트에만 있는 특이한 단어를 규칙에 넣어서라도 그 순간만큼은 AI처럼 보이게 만드세요.

2.  **"AI인 척"하는 룰 베이스:**
    *   지금 코드의 `_validate_disclosure_internal`에 있는 로직들(`if "이사회" not in...`)은 아주 훌륭합니다. 이걸 몇 개 더 늘리세요.
    *   `suggestion` 메시지를 아주 그럴싸하고 전문적으로 작성해두면, 사용자는 뒷단에서 LLM이 깊게 고민한 줄 압니다.

3.  **LLM은 "생성"에만 집중:**
    *   판단(매핑/검증)은 빠르고 정확한 하드코딩(룰)으로 하고,
    *   결과 문장을 부드럽게 다듬거나 초안을 작성하는(`draft_ifrs_s2_disclosure`) 부분에만 LLM을 쓰세요. 여기가 LLM이 제일 잘하고 티가 많이 나는 부분입니다.

**결론:**
지금 코드 지우지 마세요. 오히려 `RULES` 리스트를 더 채우고, `ValidationIssue`의 메시지를 더 예쁘게 다듬는 데 시간을 쓰세요. **구조 개선은 해커톤 끝나고 리팩토링할 때 해도 충분합니다.** 화이팅입니다